use num_traits::Zero;

use super::component::WideFibComponent;
use crate::core::air::accumulation::{DomainEvaluationAccumulator, PointEvaluationAccumulator};
use crate::core::air::mask::fixed_mask_points;
use crate::core::air::{Component, ComponentTrace};
use crate::core::backend::{CPUBackend, Column};
use crate::core::circle::CirclePoint;
use crate::core::constraints::coset_vanishing;
use crate::core::fields::m31::BaseField;
use crate::core::fields::qm31::SecureField;
use crate::core::fields::FieldExpOps;
use crate::core::poly::circle::CanonicCoset;
use crate::core::utils::bit_reverse;
use crate::core::ColumnVec;

impl Component<CPUBackend> for WideFibComponent {
    fn n_constraints(&self) -> usize {
        255
    }

    fn max_constraint_log_degree_bound(&self) -> u32 {
        self.log_size + 1
    }

    fn trace_log_degree_bounds(&self) -> Vec<u32> {
        vec![self.log_size; 256]
    }

    fn mask_points(
        &self,
        point: CirclePoint<SecureField>,
    ) -> ColumnVec<Vec<CirclePoint<SecureField>>> {
        fixed_mask_points(&vec![vec![0_usize]; 256], point)
    }

    fn evaluate_constraint_quotients_on_domain(
        &self,
        trace: &ComponentTrace<'_, CPUBackend>,
        evaluation_accumulator: &mut DomainEvaluationAccumulator<CPUBackend>,
    ) {
        let max_constraint_degree = Component::<CPUBackend>::max_constraint_log_degree_bound(self);
        let trace_eval_domain = CanonicCoset::new(max_constraint_degree).circle_domain();
        let mut trace_evals = vec![];
        for poly_index in 0..256 {
            let poly = &trace.polys[poly_index];
            trace_evals.push(poly.evaluate(trace_eval_domain));
        }
        let zero_domain = CanonicCoset::new(self.log_size).coset;
        let mut denoms = vec![];
        for point in trace_eval_domain.iter() {
            denoms.push(coset_vanishing(zero_domain, point));
        }
        bit_reverse(&mut denoms);
        let mut denom_inverses = vec![BaseField::zero(); 1 << (max_constraint_degree)];
        BaseField::batch_inverse(&denoms, &mut denom_inverses);
        let mut numerators = vec![SecureField::zero(); 1 << (max_constraint_degree)];
        let [mut accum] = evaluation_accumulator.columns([(
            max_constraint_degree,
            Component::<CPUBackend>::n_constraints(self),
        )]);

        #[allow(clippy::needless_range_loop)]
        for i in 0..trace_eval_domain.size() {
            // Boundary constraint.
            numerators[i] += accum.random_coeff_powers[254]
                * (trace_evals[0].values.at(i) - BaseField::from_u32_unchecked(1));

            // Step constraints.
            for j in 0..254 {
                numerators[i] += accum.random_coeff_powers[253 - j]
                    * (trace_evals[j].values.at(i).square()
                        + trace_evals[j + 1].values.at(i).square()
                        - trace_evals[j + 2].values.at(i));
            }
        }
        for (i, (num, denom)) in numerators.iter().zip(denom_inverses.iter()).enumerate() {
            accum.accumulate(i, *num * *denom);
        }
    }

    fn evaluate_constraint_quotients_at_point(
        &self,
        point: CirclePoint<SecureField>,
        mask: &ColumnVec<Vec<SecureField>>,
        evaluation_accumulator: &mut PointEvaluationAccumulator,
    ) {
        let constraint_zero_domain = CanonicCoset::new(self.log_size).coset;
        let denom = coset_vanishing(constraint_zero_domain, point);
        let denom_inverse = denom.inverse();
        let numerator = mask[0][0] - BaseField::from_u32_unchecked(1);
        evaluation_accumulator.accumulate(numerator * denom_inverse);

        for i in 0..254 {
            let numerator = mask[i][0].square() + mask[i + 1][0].square() - mask[i + 2][0];
            evaluation_accumulator.accumulate(numerator * denom_inverse);
        }
    }
}
